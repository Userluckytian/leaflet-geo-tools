<!DOCTYPE html>
<html>
<head>
    <title>Leaflet Geo Tools Demo</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body {
            margin: 20px;
            font-family: Arial, sans-serif;
        }
        #map { 
            height: 500px; 
            margin-top: 20px;
            border: 2px solid #ddd;
            border-radius: 5px;
        }
        .toolbar {
            margin: 15px 0;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 5px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            background: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: #005fa3;
        }
        button.active {
            background: #ff6b6b;
        }
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        #log {
            margin-top: 20px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 5px;
            min-height: 100px;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }
        .status {
            margin-top: 10px;
            padding: 5px 10px;
            background: #e6f7ff;
            border-left: 4px solid #007acc;
        }
    </style>
</head>
<body>
    <h1>Leaflet Geo Tools Demo</h1>
    
    <div class="status" id="status">çŠ¶æ€: å‡†å¤‡å°±ç»ª</div>
    
    <div class="toolbar">
        <h3>ç»˜åˆ¶å·¥å…·</h3>
        <button id="drawMarker">ğŸ“ ç»˜åˆ¶ Marker</button>
        <button id="drawPolyline">ğŸ“ ç»˜åˆ¶æŠ˜çº¿</button>
        <button id="drawPolygon">ğŸ”· ç»˜åˆ¶å¤šè¾¹å½¢</button>
        <button id="drawRectangle">â¬œ ç»˜åˆ¶çŸ©å½¢</button>
        <button id="drawCircle">â­• ç»˜åˆ¶åœ†å½¢</button>
        <button id="stopDrawing" disabled>ğŸ›‘ åœæ­¢ç»˜åˆ¶</button>
    </div>
    
    <div class="toolbar">
        <h3>æµ‹é‡å·¥å…·</h3>
        <button id="measureDistance">ğŸ“ æµ‹é‡è·ç¦»</button>
        <button id="measureArea">ğŸ“ æµ‹é‡é¢ç§¯</button>
        <button id="stopMeasure" disabled>ğŸ›‘ åœæ­¢æµ‹é‡</button>
    </div>
    
    <div class="toolbar">
        <h3>ç¼–è¾‘å·¥å…·</h3>
        <button id="clearAll">ğŸ§¹ æ¸…é™¤æ‰€æœ‰</button>
        <button id="logFeatures">ğŸ“„ è¾“å‡º GeoJSON</button>
    </div>
    
    <div id="map"></div>
    
    <div id="log"></div>
    
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- è¿™é‡Œå‡è®¾ä½ çš„åº“æš´éœ²ä¸ºå…¨å±€å˜é‡ LeafletGeoTools -->
    <!-- å¦‚æœè¿˜æ²¡æœ‰ï¼Œæˆ‘ä»¬å¯ä»¥ç¨åä¿®æ”¹ -->
    <script src="../dist/index.js"></script>
    
    <script>
        // åˆå§‹åŒ–åœ°å›¾
        const map = L.map('map').setView([51.505, -0.09], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
        
        // å…¨å±€å˜é‡æ¥è·Ÿè¸ªå½“å‰æ¿€æ´»çš„ç¼–è¾‘å™¨
        let currentEditor = null;
        let editors = []; // å­˜å‚¨æ‰€æœ‰ç¼–è¾‘å™¨å®ä¾‹
        
        // è·å– DOM å…ƒç´ 
        const statusEl = document.getElementById('status');
        const logEl = document.getElementById('log');
        
        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        function updateStatus(message) {
            statusEl.textContent = `çŠ¶æ€: ${message}`;
            log(message);
        }
        
        // æ—¥å¿—å‡½æ•°
        function log(message) {
            const time = new Date().toLocaleTimeString();
            logEl.innerHTML += `[${time}] ${message}\n`;
            logEl.scrollTop = logEl.scrollHeight; // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
        }
        
        // æ¸…ç†å‡½æ•°
        function cleanupCurrentEditor() {
            if (currentEditor) {
                try {
                    // åœæ­¢å½“å‰ç¼–è¾‘å™¨çš„æ´»åŠ¨
                    if (currentEditor.exitEditMode) currentEditor.exitEditMode();
                    if (currentEditor.destroy) currentEditor.destroy();
                    updateStatus(`å·²åœæ­¢ ${currentEditor.constructor.name}`);
                } catch (error) {
                    log(`æ¸…ç†ç¼–è¾‘å™¨æ—¶å‡ºé”™: ${error.message}`);
                }
                currentEditor = null;
            }
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.getElementById('stopDrawing').disabled = true;
            document.getElementById('stopMeasure').disabled = true;
            
            // ç§»é™¤æ‰€æœ‰æŒ‰é’®çš„ active ç±»
            document.querySelectorAll('button').forEach(btn => {
                btn.classList.remove('active');
            });
        }
        
        // æ£€æŸ¥æ˜¯å¦å¯¼å‡ºäº†å…¨å±€å˜é‡
        function checkLibrary() {
            // å°è¯•ä¸åŒçš„å¯èƒ½å¯¼å‡ºçš„å…¨å±€å˜é‡å
            const library = window.LeafletGeoTools || window.leafletGeoTools || window.geoTools;
            
            if (!library) {
                updateStatus("é”™è¯¯: æœªæ‰¾åˆ° Leaflet Geo Tools åº“ã€‚è¯·ç¡®ä¿ dist/index.js å·²æ­£ç¡®æ„å»ºã€‚");
                console.error('å…¨å±€å˜é‡æœªæ‰¾åˆ°ã€‚è¯·æ£€æŸ¥ï¼š');
                console.error('1. æ˜¯å¦è¿è¡Œäº† npm run build?');
                console.error('2. æ‰“åŒ…é…ç½®æ˜¯å¦è®¾ç½®äº†æ­£ç¡®çš„å…¨å±€å˜é‡å?');
                console.error('3. å½“å‰å¯ç”¨çš„å…¨å±€å˜é‡:', Object.keys(window).filter(k => k.includes('Leaflet') || k.includes('leaflet')));
                return null;
            }
            
            updateStatus(`åº“å·²åŠ è½½: ${Object.keys(library).length} ä¸ªå¯¼å‡ºé¡¹`);
            console.log('å¯ç”¨çš„å¯¼å‡º:', Object.keys(library));
            return library;
        }
        
        // ç»˜åˆ¶ Marker
        document.getElementById('drawMarker').addEventListener('click', async () => {
            cleanupCurrentEditor();
            
            const lib = checkLibrary();
            if (!lib) return;
            
            try {
                // æ³¨æ„ï¼šä½ å¯èƒ½éœ€è¦æ ¹æ®å®é™…çš„ç±»åè°ƒæ•´
                // ä¾‹å¦‚ï¼šlib.LeafletMarkerEditor æˆ– lib.MarkerEditor
                const MarkerClass = lib.LeafletMarkerEditor || lib.MarkerPointEditor || lib.default?.LeafletMarkerEditor;
                
                if (!MarkerClass) {
                    updateStatus("é”™è¯¯: æœªæ‰¾åˆ° Marker ç¼–è¾‘å™¨ç±»");
                    log("å¯ç”¨çš„ç±»: " + Object.keys(lib).filter(k => k.includes('Marker') || k.includes('marker')).join(', '));
                    return;
                }
                
                updateStatus("å¼€å§‹ç»˜åˆ¶ Marker - è¯·åœ¨åœ°å›¾ä¸Šç‚¹å‡»æ·»åŠ æ ‡è®°");
                currentEditor = new MarkerClass(map);
                editors.push(currentEditor);
                
                // ç›‘å¬çŠ¶æ€å˜åŒ–
                if (currentEditor.onStateChange) {
                    currentEditor.onStateChange((state) => {
                        updateStatus(`Marker ç¼–è¾‘å™¨çŠ¶æ€: ${state}`);
                        if (state === 'idle' || state === 'Idle') {
                            document.getElementById('stopDrawing').disabled = true;
                            document.getElementById('drawMarker').classList.remove('active');
                            updateStatus("Marker ç»˜åˆ¶å®Œæˆ");
                        }
                    });
                }
                
                // æ›´æ–° UI
                document.getElementById('stopDrawing').disabled = false;
                document.getElementById('drawMarker').classList.add('active');
                
                log("Marker ç¼–è¾‘å™¨å·²å¯åŠ¨");
                
            } catch (error) {
                updateStatus(`é”™è¯¯: ${error.message}`);
                log(`åˆ›å»º Marker ç¼–è¾‘å™¨å¤±è´¥: ${error.stack}`);
            }
        });
        
        // ç»˜åˆ¶å¤šè¾¹å½¢
        document.getElementById('drawPolygon').addEventListener('click', async () => {
            cleanupCurrentEditor();
            
            const lib = checkLibrary();
            if (!lib) return;
            
            try {
                const PolygonClass = lib.LeafletPolygonEditor || lib.PolygonEditor || lib.default?.LeafletPolygonEditor;
                
                if (!PolygonClass) {
                    updateStatus("é”™è¯¯: æœªæ‰¾åˆ°å¤šè¾¹å½¢ç¼–è¾‘å™¨ç±»");
                    log("å¯ç”¨çš„ç±»: " + Object.keys(lib).filter(k => k.includes('Polygon') || k.includes('polygon')).join(', '));
                    return;
                }
                
                updateStatus("å¼€å§‹ç»˜åˆ¶å¤šè¾¹å½¢ - ç‚¹å‡»æ·»åŠ é¡¶ç‚¹ï¼ŒåŒå‡»å®Œæˆç»˜åˆ¶");
                currentEditor = new PolygonClass(map);
                editors.push(currentEditor);
                
                // ç›‘å¬çŠ¶æ€å˜åŒ–
                if (currentEditor.onStateChange) {
                    currentEditor.onStateChange((state) => {
                        updateStatus(`å¤šè¾¹å½¢ç¼–è¾‘å™¨çŠ¶æ€: ${state}`);
                        if (state === 'idle' || state === 'Idle') {
                            document.getElementById('stopDrawing').disabled = true;
                            document.getElementById('drawPolygon').classList.remove('active');
                            updateStatus("å¤šè¾¹å½¢ç»˜åˆ¶å®Œæˆ");
                            
                            // è¾“å‡º GeoJSON
                            if (currentEditor.geojson) {
                                const geojson = currentEditor.geojson();
                                log(`å¤šè¾¹å½¢ GeoJSON: ${JSON.stringify(geojson, null, 2)}`);
                            }
                        }
                    });
                }
                
                // æ›´æ–° UI
                document.getElementById('stopDrawing').disabled = false;
                document.getElementById('drawPolygon').classList.add('active');
                
                log("å¤šè¾¹å½¢ç¼–è¾‘å™¨å·²å¯åŠ¨");
                
            } catch (error) {
                updateStatus(`é”™è¯¯: ${error.message}`);
                log(`åˆ›å»ºå¤šè¾¹å½¢ç¼–è¾‘å™¨å¤±è´¥: ${error.stack}`);
            }
        });
        
        // ç»˜åˆ¶çŸ©å½¢
        document.getElementById('drawRectangle').addEventListener('click', async () => {
            cleanupCurrentEditor();
            
            const lib = checkLibrary();
            if (!lib) return;
            
            try {
                const RectangleClass = lib.LeafletRectangleEditor || lib.RectangleEditor || lib.default?.LeafletRectangleEditor;
                
                if (!RectangleClass) {
                    updateStatus("é”™è¯¯: æœªæ‰¾åˆ°çŸ©å½¢ç¼–è¾‘å™¨ç±»");
                    log("å¯ç”¨çš„ç±»: " + Object.keys(lib).filter(k => k.includes('Rectangle') || k.includes('rectangle')).join(', '));
                    return;
                }
                
                updateStatus("å¼€å§‹ç»˜åˆ¶çŸ©å½¢ - ç‚¹å‡»å¹¶æ‹–åŠ¨ç»˜åˆ¶");
                currentEditor = new RectangleClass(map);
                editors.push(currentEditor);
                
                if (currentEditor.onStateChange) {
                    currentEditor.onStateChange((state) => {
                        updateStatus(`çŸ©å½¢ç¼–è¾‘å™¨çŠ¶æ€: ${state}`);
                        if (state === 'idle' || state === 'Idle') {
                            document.getElementById('stopDrawing').disabled = true;
                            document.getElementById('drawRectangle').classList.remove('active');
                            updateStatus("çŸ©å½¢ç»˜åˆ¶å®Œæˆ");
                        }
                    });
                }
                
                document.getElementById('stopDrawing').disabled = false;
                document.getElementById('drawRectangle').classList.add('active');
                log("çŸ©å½¢ç¼–è¾‘å™¨å·²å¯åŠ¨");
                
            } catch (error) {
                updateStatus(`é”™è¯¯: ${error.message}`);
                log(`åˆ›å»ºçŸ©å½¢ç¼–è¾‘å™¨å¤±è´¥: ${error.stack}`);
            }
        });
        
        // æµ‹é‡è·ç¦»
        document.getElementById('measureDistance').addEventListener('click', async () => {
            cleanupCurrentEditor();
            
            const lib = checkLibrary();
            if (!lib) return;
            
            try {
                const DistanceClass = lib.LeafletDistanceMeasure || lib.DistanceMeasure || lib.measure?.distance || lib.default?.LeafletDistanceMeasure;
                
                if (!DistanceClass) {
                    updateStatus("é”™è¯¯: æœªæ‰¾åˆ°è·ç¦»æµ‹é‡ç±»");
                    return;
                }
                
                updateStatus("å¼€å§‹æµ‹é‡è·ç¦» - ç‚¹å‡»æ·»åŠ æµ‹é‡ç‚¹ï¼ŒåŒå‡»å®Œæˆ");
                currentEditor = new DistanceClass(map);
                editors.push(currentEditor);
                
                if (currentEditor.onStateChange) {
                    currentEditor.onStateChange((state) => {
                        updateStatus(`è·ç¦»æµ‹é‡çŠ¶æ€: ${state}`);
                        if (state === 'idle' || state === 'Idle') {
                            document.getElementById('stopMeasure').disabled = true;
                            document.getElementById('measureDistance').classList.remove('active');
                            updateStatus("è·ç¦»æµ‹é‡å®Œæˆ");
                        }
                    });
                }
                
                document.getElementById('stopMeasure').disabled = false;
                document.getElementById('measureDistance').classList.add('active');
                log("è·ç¦»æµ‹é‡å·²å¯åŠ¨");
                
            } catch (error) {
                updateStatus(`é”™è¯¯: ${error.message}`);
                log(`å¯åŠ¨è·ç¦»æµ‹é‡å¤±è´¥: ${error.stack}`);
            }
        });
        
        // æµ‹é‡é¢ç§¯
        document.getElementById('measureArea').addEventListener('click', async () => {
            cleanupCurrentEditor();
            
            const lib = checkLibrary();
            if (!lib) return;
            
            try {
                const AreaClass = lib.LeafletAreaMeasure || lib.AreaMeasure || lib.measure?.area || lib.default?.LeafletAreaMeasure;
                
                if (!AreaClass) {
                    updateStatus("é”™è¯¯: æœªæ‰¾åˆ°é¢ç§¯æµ‹é‡ç±»");
                    return;
                }
                
                updateStatus("å¼€å§‹æµ‹é‡é¢ç§¯ - ç‚¹å‡»æ·»åŠ é¡¶ç‚¹ï¼ŒåŒå‡»å®Œæˆ");
                currentEditor = new AreaClass(map);
                editors.push(currentEditor);
                
                if (currentEditor.onStateChange) {
                    currentEditor.onStateChange((state) => {
                        updateStatus(`é¢ç§¯æµ‹é‡çŠ¶æ€: ${state}`);
                        if (state === 'idle' || state === 'Idle') {
                            document.getElementById('stopMeasure').disabled = true;
                            document.getElementById('measureArea').classList.remove('active');
                            updateStatus("é¢ç§¯æµ‹é‡å®Œæˆ");
                        }
                    });
                }
                
                document.getElementById('stopMeasure').disabled = false;
                document.getElementById('measureArea').classList.add('active');
                log("é¢ç§¯æµ‹é‡å·²å¯åŠ¨");
                
            } catch (error) {
                updateStatus(`é”™è¯¯: ${error.message}`);
                log(`å¯åŠ¨é¢ç§¯æµ‹é‡å¤±è´¥: ${error.stack}`);
            }
        });
        
        // åœæ­¢ç»˜åˆ¶/æµ‹é‡
        document.getElementById('stopDrawing').addEventListener('click', () => {
            cleanupCurrentEditor();
            updateStatus("å·²åœæ­¢å½“å‰ç»˜åˆ¶æ“ä½œ");
        });
        
        document.getElementById('stopMeasure').addEventListener('click', () => {
            cleanupCurrentEditor();
            updateStatus("å·²åœæ­¢å½“å‰æµ‹é‡æ“ä½œ");
        });
        
        // æ¸…é™¤æ‰€æœ‰
        document.getElementById('clearAll').addEventListener('click', () => {
            editors.forEach(editor => {
                try {
                    if (editor.destroy) editor.destroy();
                    else if (editor.remove) editor.remove();
                } catch (error) {
                    // å¿½ç•¥æ¸…ç†é”™è¯¯
                }
            });
            
            editors = [];
            cleanupCurrentEditor();
            updateStatus("å·²æ¸…é™¤æ‰€æœ‰å›¾å±‚");
            log("æ‰€æœ‰å›¾å±‚å·²æ¸…é™¤");
        });
        
        // è¾“å‡º GeoJSON
        document.getElementById('logFeatures').addEventListener('click', () => {
            log("=== å½“å‰æ‰€æœ‰è¦ç´ çš„ GeoJSON ===");
            
            editors.forEach((editor, index) => {
                if (editor.geojson) {
                    try {
                        const geojson = editor.geojson();
                        log(`è¦ç´  ${index + 1} (${editor.constructor?.name || 'æœªçŸ¥'}):`);
                        log(JSON.stringify(geojson, null, 2));
                    } catch (error) {
                        log(`è·å–è¦ç´  ${index + 1} çš„ GeoJSON å¤±è´¥: ${error.message}`);
                    }
                }
            });
            
            if (editors.length === 0) {
                log("æ²¡æœ‰å¯è¾“å‡ºçš„è¦ç´ ");
            }
        });
        
        // åˆå§‹æ—¥å¿—
        updateStatus("é¡µé¢åŠ è½½å®Œæˆï¼Œç‚¹å‡»æŒ‰é’®å¼€å§‹æµ‹è¯•");
        log("Leaflet Geo Tools æµ‹è¯•é¡µé¢å·²åŠ è½½");
        log("åœ°å›¾ä¸­å¿ƒ: [51.505, -0.09], ç¼©æ”¾çº§åˆ«: 13");
        
        // æ£€æŸ¥åº“æ˜¯å¦åŠ è½½æˆåŠŸ
        setTimeout(() => {
            const lib = checkLibrary();
            if (lib) {
                log("åº“åŠ è½½æˆåŠŸï¼");
            }
        }, 1000);
        
    </script>
</body>
</html>